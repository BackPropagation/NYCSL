Welcome to the Tron Tutorials! In this short series, we'll build three progressively more advanced Tron Bots: A basic bot, a wall-hugging mid bot, and an advanced Voronoi minimax bot.

<h1>Basic Bot</h1>
<p>Our first bot will be the basic bot. Its strategy is very simple: it will find where it is on the map, look at the squares around it on the map, and then move to an empty square in the order of preference of N, E, S, W.
The first thing we'll need to do for this bot is to find out where we are. To do so, we can simply iterate through the entire two-dimensional array that we're given  and check whether the square matches the value of our player:</p>
<code>
</code>
<p>Next, we need to find out what directions are safe for us to go in. To do this, we can create a boolean array with four elements in it, one for each direction, and check two things.</p>
<p>We need to confirm that the square we are checking actually exists. If it doesn't, our bot will fail because it will try to check the value of a square which doesn't exist, which will make it crash.</p>
<p>We need to check that the square is empty.</p>
<p>If both of the above are true, then we will deem the square safe and put the value as true. Otherwise, we will set it to be false, or not safe.</p>
[CODE SNIPPET]
<p>Next, we can do a bit of output to make debugging easier for later, as once you modify it something is bound to break. We'll log our location and whether each individual direction is safe. To make this easier, we can also write a little function which will tell us what direction a given integer corresponds to. 0 corresponds to NORTH, 1 to EAST, 2 to SOUTH, and 3 to WEST.</p>
[CODE SNIPPET]
<p>Finally, we need to find the first direction in the order NORTH, EAST, SOUTH, WEST which is safe to go in, and to move in that direction.</p>
[CODE SNIPPET]

<h1>Wall Hugging</h1>
<p>The strategy behind wall-hugging is to choose the direction to move which is empty but also has the most adjacent walls. If there's a tie, it'll choose the direction that comes first in the order of N, E, S, W</p>
<p>First, we can write a simple function to determine the location reached when travelling from a square in a given direction. If the location doesn't exist, we can write the location { -1, -1 } to indicate that the location does not exist.</p>
[CODE SNIPPET]
<p>The second thing we can do is to modularize the basic bot's algorithm to find the free squares around a given location, given a map as well. It will return an array of 4 booleans, corresponding to whether an empty square is present in the N, E, S, W locations of the given square.</p>
[CODE SNIPPET]
<p>Next, we can again find the empty locations around our player, simply by passing in our location to the above function.</p>
[CODE SNIPPET]
<p>Then, we can create an array of 4 ints corresponding to the number of empty squares around each of the squares in the directions of N, E, S, W. If the square in the direction we examine is not empty, we will assign it to have five empty squares around it to ensure that we do not go there. Otherwise, we will simply count the number of cases of “true” when we call the function to get the empty adjacent squares and set that to the corresponding spot in the array.</p>
[CODE SNIPPET]
<p>Finally, we can find the direction with the smallest value in the above array and move that way.</p>
[CODE SNIPPET]


<h1>Minimax</h1>
<p>The minimax bot is the most advanced bot we'll implement in this tutorial series. It will simulate all sixteen possible moves (4 for us and 4 for them) one turn into the future, simulate the results, and rank the resulting game positions. The system that it uses to do rankings is called the Voronoi system after Voronoi diagrams; it takes the number of pieces we can reach before our opponent can, subtracts the number of pieces our opponent can reach before we can, and makes that the value of the position. Finally, once the moves have been simulated, it will move in the direction such that, no matter what move our opponent makes, the value of the position is as large as possible.</p>
<p>There are two important functions we'll need to write before we can make this work. The first one will be to simulate a move. It will take a map, my move, their move, and output the resulting map. If a player wins with that set of moves, it will throw an enum which is defined as:</p>
[CODE SNIPPET]: 39-43
<p>The function which does the simulation looks like:</p>
[CODE SNIPPET]: 45-72
<p>The second function we'll need efficiently finds the voronoi value of a position. To do this, it conducts a specialized breadth-first search to find how far away pieces are from us. Here's a visualization of a breadth-first search similar to what we'll use:</p> http://joseph-harrington.com/2012/02/breadth-first-search-visual/
<p>To do this, we maintain a front of the pieces we're examining, and we also maintain a new front - the pieces that we're assembling for the next front. We can then seed our search with a location, namely our location or our opponent's, and then run the search to find out how many moves are required to reach a location.</p>
[CODE SNIPPET]: 74-171
<p>Finally, we can now evaluate moves. We'll create a two dimensional, 4 by 4 array of values, and iterate through it and then simulate moves. If we win in the simulation, we'll assign it a value of 257, which is larger than any possible value on a 16 by 16 map; if we lose we'll call it -257. If it's a tie we'll let it be zero, and else we'll use our Voronoi evaluation to determine the value. In the array, the first, outer array represents our moves and the second, inner array represents their moves. So, to conduct our minimax search, all we must do is to first find the minimum of every</p>
