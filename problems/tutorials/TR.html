Welcome to the Tron Tutorials! In this short series, we'll build three progressively more advanced Tron Bots: A basic bot, a wall-hugging mid bot, and an advanced Voronoi minimax bot.

<h2>Basic Bot</h2>
<p>Our first bot will be the basic bot. Its strategy is very simple: it will find where it is on the map, look at the squares around it on the map, and then move to an empty square in the order of preference of N, E, S, W.
The first thing we'll need to do for this bot is to find out where we are. To do so, we can simply iterate through the entire two-dimensional array that we're given  and check whether the square matches the value of our player:</p>
<code>
  inline bool * emptyAjacentSquares(const std::vector< std::vector<int> > & map, const std::pair<int, int> & location) {
  	bool * empty = new bool[4];
  	empty[NORTH] = location.second != 15 && map[location.second + 1][location.first] == EMPTY;
  	empty[EAST] = location.first != 15 && map[location.second][location.first + 1] == EMPTY;
  	empty[SOUTH] = location.second != 0 && map[location.second - 1][location.first] == EMPTY;
  	empty[WEST] = location.first != 0 && map[location.second][location.first - 1] == EMPTY;
  	return empty;
  }
</code>
<p>Next, we need to find out what directions are safe for us to go in. To do this, we can create a boolean array with four elements in it, one for each direction, and check two things.</p>
<p>We need to confirm that the square we are checking actually exists. If it doesn't, our bot will fail because it will try to check the value of a square which doesn't exist, which will make it crash.</p>
<p>We need to check that the square is empty.</p>
<p>If both of the above are true, then we will deem the square safe and put the value as true. Otherwise, we will set it to be false, or not safe.</p>
[CODE SNIPPET]
<p>Next, we can do a bit of output to make debugging easier for later, as once you modify it something is bound to break. We'll log our location and whether each individual direction is safe. To make this easier, we can also write a little function which will tell us what direction a given integer corresponds to. 0 corresponds to NORTH, 1 to EAST, 2 to SOUTH, and 3 to WEST.</p>
[CODE SNIPPET]
<p>Finally, we need to find the first direction in the order NORTH, EAST, SOUTH, WEST which is safe to go in, and to move in that direction.</p>
[CODE SNIPPET]

<h2>Wall Hugging</h2>
<p>The strategy behind wall-hugging is to choose the direction to move which is empty but also has the most adjacent walls. If there's a tie, it'll choose the direction that comes first in the order of N, E, S, W</p>
<p>First, we can write a simple function to determine the location reached when travelling from a square in a given direction. If the location doesn't exist, we can write the location { -1, -1 } to indicate that the location does not exist.</p>
[CODE SNIPPET]
<p>The second thing we can do is to modularize the basic bot's algorithm to find the free squares around a given location, given a map as well. It will return an array of 4 booleans, corresponding to whether an empty square is present in the N, E, S, W locations of the given square.</p>
[CODE SNIPPET]
<p>Next, we can again find the empty locations around our player, simply by passing in our location to the above function.</p>
[CODE SNIPPET]
<p>Then, we can create an array of 4 ints corresponding to the number of empty squares around each of the squares in the directions of N, E, S, W. If the square in the direction we examine is not empty, we will assign it to have five empty squares around it to ensure that we do not go there. Otherwise, we will simply count the number of cases of “true” when we call the function to get the empty adjacent squares and set that to the corresponding spot in the array.</p>
[CODE SNIPPET]
<p>Finally, we can find the direction with the smallest value in the above array and move that way.</p>
[CODE SNIPPET]
